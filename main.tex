\documentclass{article}
\usepackage{xeCJK}
\usepackage[english]{babel}
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{amssymb}
\usepackage{siunitx}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{cleveref}
\usepackage[utf8]{inputenc}
\usepackage[right]{lineno}
\usepackage{csquotes}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{url}
\usepackage{titlesec}
\usepackage{listings}
%\usepackage[compatibility=false]{caption}
\usepackage{authblk}
\usepackage{enumitem}
\usepackage{xcolor} % Load the xcolor package for color options
\renewcommand{\thetable}{\Roman{table}}

% Define a new format for \subsection
\titleformat{\subsection}
  {\mdseries\itshape\large} % Medium series, italic shape, and large font size
  {\thesubsection}{1em}{} % Numbering, spacing, and the section title itself

\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
  language=Python,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  captionpos=b,
  tabsize=4,
  showstringspaces=false
}




% 加载语言包
\usepackage[english]{babel}

% 加载 biblatex 宏包，设置引用样式和排序方式
\usepackage[style=numeric,backend=biber,sorting=none,natbib=true,maxcitenames=2,uniquelist=false]{biblatex}

% 添加 .bib 文件
\addbibresource{reference.bib} 

% Customizing biblatex for Harvard style
% Customizing biblatex for Harvard style
\DeclareNameAlias{sortname}{family-given}
\DeclareNameAlias{default}{family-given}

\renewbibmacro{in:}{}
\DeclareFieldFormat[article]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[book]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[bookinbook]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[inbook]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[incollection]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[inproceedings]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[manual]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[misc]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[thesis]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[unpublished]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[patent]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[report]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[online]{title}{\mkbibquote{#1}\addcomma}
\DeclareFieldFormat[software]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[booklet]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[periodical]{title}{\mkbibemph{#1}\addcomma}
\DeclareFieldFormat[standard]{title}{\mkbibemph{#1}\addcomma}

\DeclareFieldFormat[article]{journaltitle}{\iffieldundef{shortjournal}{\mkbibemph{#1}\addcomma}{\mkbibemph{\printfield{shortjournal}}\addcomma}}
\DeclareFieldFormat{volume}{\bibstring{volume}~#1}
\DeclareFieldFormat{number}{\bibstring{number}~#1}

\DefineBibliographyStrings{english}{
  volume = {Vol.},
  number = {No.}
}

\renewbibmacro*{volume+number+eid}{%
  \printfield{volume}%
  \setunit*{\addspace}%
  \printfield{number}%
  \setunit{\addcomma\space}%
  \printfield{eid}}

\renewbibmacro*{journal+issuetitle}{%
  \usebibmacro{journal}%
  \setunit*{\addcomma\space}%
  \usebibmacro{volume+number+eid}%
  \setunit{\addcomma\space}%
  \usebibmacro{issue+date}}

\renewbibmacro*{publisher+location+date}{%
  \printlist{publisher}%
  \iflistundef{location}
    {\setunit*{\addcomma\space}}
    {\setunit*{\addcolon\space}}%
  \printlist{location}%
  \setunit*{\addcomma\space}%
  \usebibmacro{date}}

\renewcommand*{\bibpagespunct}{\addcomma\space}


\DeclareCiteCommand{\cite}[\mkbibparens]
  {\usebibmacro{prenote}}
  {\usebibmacro{citeindex}%
   \usebibmacro{cite}}
  {\multicitedelim}
  {\usebibmacro{postnote}}

\renewbibmacro*{cite:labelyear+extrayear}{%
  \iffieldundef{labelyear}
    {}
    {\printtext[bibhyperref]{%
       \printfield{labelyear}%
       \printfield{extrayear}}}}

\renewbibmacro*{cite:labeldate+extradate}{%
  \iffieldundef{labelyear}
    {}
    {\printtext[bibhyperref]{%
       \printfield{labelyear}%
       \printfield{extradate}}}}

\AtEveryBibitem{
  \clearfield{month}
  \clearfield{day}
  \ifentrytype{book}{
    \clearlist{location}
  }{}
}


% Formatting "et al." in italics followed by a comma
\DefineBibliographyStrings{english}{
  andothers = {\textit{et al.},}
}

\DeclareFieldFormat[article]{volume}{\bibstring{jourvol}\addnbspace #1}
\DeclareFieldFormat[article]{number}{\bibstring{number}\addnbspace #1}
\DeclareFieldFormat[article]{volume}{Vol. #1}
\DeclareFieldFormat[article]{number}{No. #1}
% Customizing DOI field format to lowercase "doi"
%\DeclareFieldFormat{doi}{\bibstring{doi}\addcolon\space\url{#1}}

% Customizing URL field format to "available at:"
\DeclareFieldFormat{url}{\bibstring{available at}\addcolon\space\url{#1}}
\DeclareFieldFormat{urldate}{\mkbibparens{accessed \addspace#1}}

% Customizing urldate to match the required format
\DeclareFieldFormat{urldate}{%
  \mkbibparens{accessed\space%
    \thefield{urlday}\addspace%
    \mkbibmonth{\thefield{urlmonth}}\addspace%
    \thefield{urlyear}}}


% Configure cleveref
\crefformat{figure}{#2Figure~#1#3}
\Crefformat{figure}{#2Figure~#1#3}
\crefformat{table}{#2Table~#1#3}
\Crefformat{table}{#2Table~#1#3}
\crefformat{section}{#2Section~#1#3}
\Crefformat{section}{#2Section~#1#3}

%Front Matter
\author{邹志山}


\affil{人工智能学院\quad  2022219106班 \quad 2022212133}


\title{2025年软件定义网络课程读书报告}


\begin{document}
\maketitle


\section{作业要求}
\subsection*{\textbf{读书报告}} 

\begin{enumerate}

    \item 请每位同学从给定的10篇网络领域高水平英文论文中任选一篇，结合自己的思考独立完成一篇读书报告。
    \item 请同学们\textbf{\textcolor{red}{6月27日24：00之前}}
    提交读书报告到\textbf{\textcolor{red}{zuokangjia@bupt.edu.cn}}，报告名称统一为“学号-姓名-SDN读书报告”。最后评分将根据同学们报告内容的完成程度进行评分。
    \item 读书报告的内容必须包括：(1)背景、问题、解决方案的总结，(2)谈谈你对方案的理解。
    \item 有想法和能力的同学可以继续选择以下内容进行扩展：(3)能不能找到改进或提高的地方，(4)能否提出具体的方法，(5)进行系统设计并实现，⑥如何构造仿真环境并验证自己的想法。
    \item 如有关于课程作业方面的疑问，可以在对应课程的  QQ群（1033055198）内进行反馈，或与助教联系（电话:17865029803）。

\end{enumerate}

\subsection*{\textbf{完成作业}}
\quad\quad 选择\textbf{《OpenFlow:Enabling Innovation in Campus Networks》}\cite{mckeown2008openflow}论文进行学习，并完成读书报告,并进行系统设计实现方案的改进或提高工作。


\section{相关工作}
\subsection{\textbf{OpenFlow的起源}}
\quad\quad OpenFlow起源\cite{huawei_openflow}于斯坦福大学的Clean Slate项目\footnote{维基百科:\url{https://en.wikipedia.org/wiki/Clean_Slate_Program}}，该项目的目标是要“重塑互联网”，旨在改变设计已略显不合时宜，且难以进化发展的现有网络基础架构。Clean Slate项目的负责人Nick McKeown教授及其团队发现，如果
\textbf{将传统网络设备的数据转发和路由控制两个功能模块相分离，通过集中式的Controller以标准化的接口对各种网络设备进行管理和配置},那么这将为网络资源的设计、管理和使用提供更多的可能性，从而更容易推动网络的革新与发展。

于是，他们提出了OpenFlow的概念，并且于2008年发表了题为\textbf{《OpenFlow: Enabling Innovation in Campus Networks》}的论文，首次详细地介绍了OpenFlow的原理和应用场景。基于OpenFlow协议，2009年该研究团队进一步提出了SDN（Software Defined Network————软件定义网络）的概念，引起了行业的广泛关注和重视。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.82\textwidth]{Figures/OpenFlow.png}
    \caption{OpenFlow版本变迁}
\end{figure}

\subsection{\textbf{SDN的发展}}
\quad\quad \textbf{SDN} 自 2009 年 OpenFlow 1.0 发布以来，逐步从实验技术向产业化演进。作为 SDN 的核心协议，OpenFlow 历经多个版本迭代，并催生了 Wireshark 插件、liboftrace 调试工具等生态组件的出现。

2011 年，Nick McKeown 等人推动成立 \textbf{开放网络基金会（ONF）}\footnote{2023年12月，\textbf{ONF宣布与Linux基金会合并}，将其项目LF Broadband、Aether和P4移交给Linux基金会，并提供500万美元资金支持这些项目的运营。}，由 Google、Facebook、微软等七家企业创立，推动 SDN 标准化。同年，美国印第安纳大学等发起 NDDI 计划，探索 OpenFlow 在科研网络中的应用。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{Figures/SDN.png}
    \caption{SDN的发展历程}
\end{figure}

2012 年，\textbf{SDN 进入规模化部署阶段}。美国 INTERNET2 项目 在高校部署 SDN\footnote{北京邮电大学于2014年启动了基于SDN校园网络创新环境建设。该项目旨在通过将网络控制平面与数据平面分离，增强网络的灵活性和可扩展性。}
，
德国电信等运营商开始研究 SDN 方案。Google 采用 OpenFlow 优化流量工程，使广域网链路利用率接近饱和。同年，VMware 以 12.6 亿美元收购 Nicira，推动网络虚拟化。


同年，科技部批准 “863” 计划——\textbf{未来网络体系结构和创新环境（FINE）}，由清华大学、中科院计算所、\textbf{北京邮电大学}等单位牵头。基于FINE体系结构，将支撑各种新型网络体系结构和IPv6新协议的研究试验。


\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{Figures/FINE.png}
    \caption{FINE体系结构\cite{fine}}
\end{figure}


2013 年，\textbf{SDN 进入开源生态阶段}。思科、IBM 牵头 Open Daylight 项目，在 Linux 基金会支持下开发 SDN 控制器。中国三大运营商在 SDN 大会 上提出 S-NICE 标准，推进 SDN 在 NGN 网络中的应用。

2014年，\textbf{SDN 产业化加速}，OpenFlow 1.5 发布，增强多表流水线与流规则管理，Google 在 B4 网络实现 SDN 规模化应用，公有云厂商优化数据中心网络。可编程硬件正在推动计算与网络领域发展\footnote{以 FPGA为代表的可编程硬件因其高度并行的处理能力和灵活的硬件定义特性，在 机器学习推理阶段，尤其是对CNN、Transformer 等模型的加速计算中被广泛应用。}，Barefoot 推出 \textbf{P4 语言}，可构建的可编程数据平面可与 SDN 控制平面协同工作，增强网络的灵活性与可观测性，推动自适应网络、意图驱动网络的发展。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Figures/P4.png}
    \caption{P4-v1model\cite{p4spec}}
\end{figure}



2017年，\textbf{SDN 智能化演进}，Google 利用强化学习优化流量工程，IBN（意图驱动网络）兴起，结合 AI 进行策略编排。SDN 深入 5G 核心网，支持网络切片与边缘计算。ONAP 成为主流编排平台，OpenDaylight 支持 SRv6、BGP-LS，实现跨域控制。


2021年至今，\textbf{SDN 迈向云原生}，CNI 在 Kubernetes 生态普及，公有云强化自动化编排。SDN 结合 IBN 与闭环自动化，提升自适应调优能力，在 5G、边缘计算、DCI 等领域持续深化。



\subsection{\textbf{研究意义}}

\quad\quad SDN 由 OpenFlow 驱动，经历从学术探索到产业落地的演进。随着 OpenFlow 迭代、网络虚拟化（NFV）、意图驱动网络（IBN）等技术发展，SDN 在广域网、数据中心、5G 核心网等领域实现规模化应用。近年来，SDN 结合 AI 进行智能编排，推动可编程数据平面、云原生网络和自动化闭环控制，成为未来网络架构的核心技术之一。


\textbf{北邮} 也在 SDN 领域开展了深入研究，并积极推进其应用与实践。2014 年，北邮建设了 SDN 试验网络\cite{bupt2013}，覆盖校园内多个核心区域，并实现了与\textbf{南京未来网络产业与创新中心}\footnote{该中心承担国家重大科技基础设施项目——未来网络试验设施（CENI）的建设与运营。CENI 项目于 2013 年被国务院列入国家重大科技基础设施建设项目，是我国通信与信息领域首个此类设施，已被纳入国家“十四五”规划。}的互联互通。该实验环境支持多虚拟网络共存，为校内科研团队提供了一个面向新型网络协议、架构及业务的验证平台，并为国家级网络创新环境的建设提供了实践经验。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Figures/BUPT.png}
    \caption{北邮校园网络创新环境拓扑}
\end{figure}


通过深入学习 OpenFlow 相关理论及 \textit{OpenFlow: Enabling Innovation in Campus Networks}论文，可以系统掌握 SDN 的核心技术原理，完善对 SDN 体系结构、控制平面与数据平面分离、流表匹配及转发机制等关键概念的理解。为未来在 SDN 相关领域的研究和开发奠定坚实的理论基础。


\section{读书报告}

\subsection{\textbf{背景}}

\quad\quad  在2008年前后，路由器与交换机大多采用封闭的专有硬件与软件架构，几乎没有实际途径能在真实或大规模流量环境中部署和测试新型网络协议。同时，传统网络设备将控制平面（如路由决策）与数据平面（如数据转发）紧密耦合，这种设计严重限制了网络控制的灵活性与可编程性。结果是，大多数来自学术界和研究机构的新思想难以在实际网络中进行验证与部署，导致整个网络基础设施被广泛认为已经“僵化”。

为应对这一问题，网络研究社区开始致力于开发可编程网络架构。实现这一目标的关键在于设计支持虚拟化的可编程交换机与路由器，使其能够并行运行多个相互隔离的实验网络，从而允许研究人员在共享硬件资源的基础上进行协议创新。可编程网络有望显著降低新思想的实验门槛，提升网络基础设施的创新速度。

然而，当时一些大型实验网络设施虽然雄心勃勃，但其建设成本高昂、部署周期长，不利于快速迭代与实践应用。在此背景下，OpenFlow 被提出，作为一种成本可控、易于部署的现实解决方案，以支持校园网络中对网络可编程性的探索与实现。


\subsection{\textbf{解决方案}}


\quad\quad  面对商业网络设备封闭、僵化的现状，以及研究型设备在性能与成本方面的种种限制，完全通用的开放平台在当时几乎无法同时满足高性能与低成本的需求。为此，Nick McKeown 等人提出了一种更为务实的折中思路：在通用性上做出适当妥协，以换取一定程度的可编程性与部署灵活性。

McKeown 等人提出了“逐步部署（incremental deployment）”的策略——在现有商用交换机中引入对 OpenFlow 的支持端口，使得研究人员可以在不影响生产流量的前提下，在校园网中并行运行实验性协议。这种方式大大降低了实验门槛，使网络创新能够直接在现实环境中开展。

OpenFlow 交换机设计旨在同时满足以下四项关键目标\cite{bolg}：

\begin{enumerate}
  \item 高性能、低成本，便于在现有商用设备中实现；
  \item 支持多种网络研究和协议实验；
  \item 实验流量与生产流量物理或逻辑隔离；
  \item 兼容厂商对封闭平台的商业需求。
\end{enumerate}


这种兼顾研究与部署的设计，使 OpenFlow 成为连接学术研究与现实网络系统之间的一座桥梁，也为后来的软件定义网络（SDN）奠定了基础。

\subsection{\textbf{具体实现}}

\subsubsection{\textbf{OpenFlow 交换机}}


\quad\quad  OpenFlow 的核心思想是将网络设备中的控制逻辑从数据转发逻辑中分离出来，使得网络可以通过集中式控制器进行编程和管理。在其具体实现中，OpenFlow 交换机扮演了关键角色。



\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/2.png}
    \caption{OpenFlow 交换机整体架构}
\end{figure}


每台 OpenFlow 交换机内部维护着一张流表（Flow Table），用于根据数据包头部字段（如源/目的 IP、MAC 地址、端口号等）进行匹配，从而决定数据包的处理方式。这些处理方式包括转发到指定端口、丢弃、修改头部字段，或将其发送到控制器等。研究人员通过控制器远程下发流表规则，从而实现对整个网络行为的集中控制。

典型的 OpenFlow 交换机由三部分组成：首先是流表，它包含多个流条目，每个条目定义了匹配规则、对应动作和统计信息；其次是控制通道，它为交换机与远程控制器之间提供了安全通信链路，便于控制器下发指令、收集数据；最后是 OpenFlow 协议，它作为一套标准接口，使得控制器能够与不同厂商的交换设备交互，定义或更新流表内容，而无需访问设备底层硬件。


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{Figures/Type0.png}
    \caption{Type 0 类型的 OpenFlow 交换机中用于匹配的数据包头字段}
\end{figure}


在具体流表设计中，每条流项包含三个核心字段。其一是用于匹配的数据包头部字段，OpenFlow 在第一代“Type 0”交换机中支持十元组匹配，既可精确标识某一 TCP 流，也可通过通配符方式实现规则聚合。其二是动作定义，即在匹配后应如何处理数据包。其三为统计字段，用于记录该条流匹配的数据包数、字节数以及上次匹配时间，以便后续维护和流表清理。
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/3.png}
    \caption{OpenFlow交换机基于流表处理数据包流程图\cite{sdnn}}
\end{figure}

数据包进入交换机后，从流表 0 开始依次匹配。若成功匹配某一流条目，交换机将执行该条目所定义的指令集，包括修改操作集（Write-Action）、清空操作集（Clear-Action）、将数据包交由其他流表进一步处理（Goto-Table）等。如果在某张表中没有匹配成功，将触发“表未命中”行为，处理方式则依据预设策略决定，例如丢弃或将数据包发送至控制器进行处理。


OpenFlow 通过这种基于流表驱动的匹配与转发机制，实现了在不修改底层硬件的前提下对网络行为的动态编排和编程，为网络研究人员提供了前所未有的灵活性和实验空间。


\subsubsection{\textbf{OpenFlow 控制器}}
\quad\quad OpenFlow 控制器通过添加、修改和删除交换机中的流表项来控制网络中数据流的行为。在实际部署中，控制器可以是一个运行在普通 PC 上的程序，其功能从简单的静态配置到复杂的动态调度不等。例如，在某些实验场景中，一个静态控制器可能只负责在一组互联主机之间建立固定的流通路径，用于模拟新的网络协议或服务。在这种用法下，流的概念类似于传统网络中的 VLAN，用于实现实验流量与生产流量的逻辑隔离，从而保障实验的可控性与安全性。从这一角度来看，OpenFlow 提供了一种广义上的 VLAN 功能，但具备更强的灵活性和可编程性。

控制器通过标准化的 OpenFlow 协议与交换机进行通信，能够远程动态地下发流表规则，实现对网络行为的精细控制。由于控制器拥有对整个网络拓扑与状态的全局视图，它能够集中地管理和调度网络资源，为多种实验性研究（如路由策略、负载均衡、安全策略等）提供平台支持。


\subsubsection{\textbf{部署 OpenFlow 交换机}}

\quad\quad 作者提出“逐步部署”策略：在现有商用交换机中引入支持 OpenFlow 的端口，使其在校园网中能够在运行生产网络的同时进行实验。在部署方面，McKeown 等人在校园网中建设了大型 OpenFlow 网络，逐步替代原有基础设施。所有数据流最终都将通过 OpenFlow 网络传输，实验流量与生产流量在网络管理员控制下被隔离于不同的 VLAN 中。研究人员能够自主控制其流量，灵活增删流表，实现真正可编程的网络环境。


\subsection{\textbf{论文总结}}

\quad\quad OpenFlow 是网络架构演进中的重要里程碑，标志着网络可编程和集中控制时代的开启，并由此引发了软件定义网络（SDN）的革命，深刻影响了数据中心网络、运营商骨干网和企业网络等多个领域。尽管其初期设计在性能、扩展性和复杂性等方面存在一定局限，但“控制与转发分离”的核心理念被广泛继承与发展，成为现代网络架构设计的基础。

OpenFlow 类似于硬件与操作系统之间的“指令集”\cite{shankland2012openflow}，它提供了网络创新的开放接口，使协议、策略的快速迭代成为可能，降低了研究与部署的门槛。正因如此，它被认为是推动网络技术由“黑盒”向“白盒”演进的关键推动力。

此外，OpenFlow 是“虚拟网络的起点”\cite{metz2012nicira}，它使网络虚拟化和逻辑分段成为可能，为后来的网络功能虚拟化（NFV）和多租户网络提供了技术基础，加速了网络基础设施的软化与服务化进程。

OpenFlow 所体现的集中控制与标准化接口理念，也回应了长期困扰传统网络的复杂性与不可验证性问题。它强调“网络架构应该简洁、可验证”，推动了面向可证明正确性的网络系统研究。

作为一种底层抽象机制，OpenFlow 可视为“网络操作系统”的南向接口，连接控制平面与数据平面，成为 SDN 控制器实现网络统一管理和资源编排的重要支撑。


\section{OpenFlow交互流程分析}
\quad\quad 在2025 年软件定义网络课程实验1中，进行了 OpenFlow建立连接交互流程学习，这里回顾OpenFlow交换机与OpenFlow控制器建立TCP连接的过程。

在OpenFlow 网络中，网络设备根据用户配置发起与控制器的连接。当控制器收到来自网络设备的 TCP 三次握手连接后开始协商，控制器和网络设备相互发送 Hello报文来协商版本。协商版本成功后，控制器向网络设备发送 Feature Request（特征请求）报文，以获取网络设备的能力集特征。网络设备在收到 Feature Request 报文后，向控制器回应 Feature Reply（特征应答）报文。这时候，控制器和网络设备成功建立连接。之后，网络设备通过周期性向控制器发送 Echo Request（环回请求）报文，并接收控制器返回的 Echo Reply（环回应答）报文来保持连接的有效性。

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{Figures/9.png}
    \caption{交换机与控制器建立TCP连接的流程}
\end{figure}


在现有技术中，网络设备与控制器一旦建立连接之后，就需要周期性（一般默认是 5 秒）的向控制器发送 Echo Request 报文，控制器在收到保活请求报文后向网络设备返回保活应答报文。网络设备上使用 VLAN 来划分实例（实例的划分有三种：基于VLAN 划分，基于端口划分、全局划分），每个实例都是单独和控制器建立连接的，由于网络设备目前支持的 VLAN 个数为 4094 个，因此网络设备最多可以支持4094 个实例。如果每个实例都和控制器建立连接（不同实例可以和相同的控制器建立连接，也可以和不同的控制器建立连接），则网络设备和一个控制器至少可以建立4094 个连接。在此基础上，假设一台网络设备上的 4094 个实例都和同一台控制器建立连接，则网络设备在每个发送周期（默认值 5 秒）内，均需要向控制器发送 4094 个 EchoRequest 报文，且控制器需要在相同的时间内向网络设备返回 4094 个Echo Reply 报文。

\textbf{显然，在发送周期内，网络设备需要发送大量的 Echo Request 报文，从而浪费网络设备的处理资源，并影响网络设备的正常使用；进一步的，控制器也需要发送大量的Echo Reply 报文，从而浪费控制器的处理资源，并影响控制器的正常使用。}\cite{wanfang_openflow}


\section{OpenFlow保活机制的优化}

\subsection{\textbf{优化算法模型}}
\quad\quad 通过在 OpenFlow 交换机上众多实例间通过协商算法选出 Master 实例，只选择Master 实例向 Controller 发送 Echo\_request 报文，同时，Controller 也只给 Master 实例回复Echo\_reply 报文来保证连接的有效性。通过众多实例间协商出 Master 实例的设备端优化保活的机制来减少 Controller 和 OpenFlow 交换机间的众多实例的
Echo\_request 和 Echo\_reply 保活报文的相互交互，从而达到降低 OpenFlow 交换机和Controller 的处理保活报文能力的损耗的目的。


\subsection{\textbf{协商算法思想}}

\quad\quad 该算法旨在多实例\cite{youkud}连接控制器（Controller）的场景下，通过选举机制确保唯一的 \textbf{Master 实例} 负责与控制器的保活交互，其余实例为 \textbf{Backup 实例}，作为备用。算法规则如下：

\begin{itemize}
    \item 第一个成功连接 Controller 的实例被设为 \textbf{Master}。
    \item 后续实例均设为 \textbf{Backup}。
    \item 一旦任一实例断开连接并重新接入，需重新执行选主过程。
    \item Master 实例负责与 Controller 的 \texttt{Echo\_request} / \texttt{Echo\_reply} 保活报文交互。
    \item Backup 实例通过监听 Master 实例的保活状态间接确认自身的连通状态。
\end{itemize}

\subsection{\textbf{协商算法流程}}

\begin{enumerate}
    \item \textbf{实例创建与连接}：交换机上的实例启动后，与 Controller 建立连接，并在 Controller 的保活链表（List）中注册节点。
    
    \item \textbf{保活链表查询}：每个实例定时查询对应的保活链表，若其节点处于链表头部，执行第 3 步；否则执行第 4 步。
    
    \item \textbf{Master 行为}：
    \begin{itemize}
        \item 被选为 Master 的实例主动向 Controller 发送 \texttt{Echo\_request}。
        \item 若收到 \texttt{Echo\_reply}，则将保活定时器归零。
        \item 若未收到响应，且定时器未超过 $3 \times$ 报文间隔，继续查询链表；否则跳转至第 5 步。
    \end{itemize}
    
    \item \textbf{Backup 行为}：
    \begin{itemize}
        \item 被设为 Backup 的实例不发送或接收 \texttt{Echo} 报文。
        \item 它将自己的保活定时器更新为当前 Master 的定时器值。
        \item 若定时器未超过 $3 \times$ 报文间隔，返回步骤 2；否则进入第 5 步。
    \end{itemize}
    
    \item \textbf{连接断开处理}：若实例与 Controller 断开连接，其节点需从保活链表中删除，并触发链表更新。
\end{enumerate}

\subsection{\textbf{算法实现要点}}

\begin{itemize}
    \item 每个实例对应一个与 Controller 的连接关系，需分别维护对应的保活链表。
    \item 所有实例使用相同的保活报文发送间隔。
    \item 实例连接成功后，其节点应立即注册到保活链表中。
    \item 实例断开连接时，其节点必须从链表中移除。
    \item 实例定期轮询链表：
    \begin{itemize}
        \item 若为链表头，则成为 Master，负责保活任务；
        \item 否则为 Backup，仅保持连接。
    \end{itemize}
    \item Master 实例收到 \texttt{Echo\_reply} 后，应立即将其保活定时器归零，维持主控地位。
\end{itemize}



     
\section{应用实例建模}

\quad\quad 本文对以下应用场景进行建模：一台 OpenFlow 交换机上的多个实例与多个 Controller 建立连接，并进行保活交互。


\begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{Figures/10.png}
    \caption{多个实例和多个Controller 建立连接}
\end{figure}


\subsection{\textbf{建模背景}}

假设存在以下连接关系：

\begin{itemize}
    \item 实例 1 与 Controller1 建立连接；
    \item 实例 2 与 Controller2、Controller3 建立连接；
    \item 实例 3 与 Controller1、Controller3 建立连接；
    \item 实例 4 与 Controller1、Controller2、Controller3 建立连接；
    \item 后续实例 2 被手动删除；
    \item 网络发生物理连接中断与修复。
\end{itemize}

\subsection{\textbf{建模步骤}}

\begin{enumerate}
    \item \textbf{实例 1 与 Controller1 建立连接}：  
    \begin{itemize}
        \item 触发创建保活链表 \textbf{List1}；
        \item 实例 1 成为链表 List1 的头结点；
        \item 实例 1 查询 List1，发现自己为头节点，故设为 \textbf{Master}；
        \item 主动发送 \texttt{Echo\_request}，并接收 \texttt{Echo\_reply}，完成保活交互。
    \end{itemize}
    
    \item \textbf{实例 2 与 Controller2、Controller3 建立连接}：
    \begin{itemize}
        \item 分别触发创建保活链表 \textbf{List2} 和 \textbf{List3}；
        \item 实例 2 成为 List2 和 List3 的头结点；
        \item 查询链表后自认是 Master，负责 Controller2 与 Controller3 的保活报文交互。
    \end{itemize}

    \item \textbf{实例 3 与实例 4 分别建立连接}：  
    \begin{itemize}
        \item 相应地更新 List1、List2、List3；
        \item 各实例根据链表头节点情况决定是否为 Master。
    \end{itemize}

    \item \textbf{保活链表状态（实例 2 删除前）}：
    
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{Figures/10.png}
    \caption{实例 2 删除前}
    \end{figure}
    
    
    

    \item \textbf{实例 2 被手动删除}：
    \begin{itemize}
        \item 实例 2 从保活链表 List2 和 List3 中移除；
        \item 实例 4 和实例 3 分别成为对应链表的新头节点，自动成为新的 Master；
        \item 负责保活报文的发送与接收。
    \end{itemize}

    \item \textbf{保活链表状态（实例 2 删除后）}：
    
    
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.75\textwidth]{Figures/11.png}
    \caption{实例 2 删除后}
    \end{figure}
    
    \item \textbf{物理连接中断}：
    \begin{itemize}
        \item Master 实例无法接收 Echo\_reply，定时器持续增长；
        \item 若超过 $3 \times$ 报文间隔阈值，则判断连接断开；
        \item 触发保活链表更新，节点被删除。
    \end{itemize}

    \item \textbf{物理连接恢复}：
    \begin{itemize}
        \item 实例重新与 Controller 建立连接；
        \item 回到第 1 步，重新判断 Master 与更新保活链表。
    \end{itemize}
\end{enumerate}



\section{应用实例仿真}

\subsection{\textbf{搭建仿真环境}}

\textbf{步骤 1}：Ryu \cite{ryu}是一个基于事件驱动的 SDN 控制器框架，支持定义事件处理函数（handler），可灵活响应如握手、流表管理、Echo Request/Reply 等 OpenFlow 消息。在本实验中，我们使用 Ryu 作为控制器。Ryu\footnote{建议使用 Python 3.10以下版本，使用虚拟环境管理} 的源码可以从其 GitHub 仓库获取：\footnote{Ryu GitHub：\url{https://github.com/faucetsdn/ryu}}\\
在终端中执行以下命令以完成安装、编译与测试运行：
\begin{lstlisting}[language=bash, caption={Ryu 控制器安装与测试}]
# 克隆 Ryu 源码仓库
git clone https://github.com/faucetsdn/ryu.git
# 进入 Ryu 目录
cd ryu

pip install --upgrade pip setuptools
pip install .

# 测试运行 Ryu 控制器
ryu-manager ryu/app/simple_switch_13.py
\end{lstlisting}


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{Figures/12.png}
    \caption{Ryu测试}
\end{figure}


\noindent \textbf{步骤2} 下载并编译 Mininet 2.3.0
从官方 GitHub 获取源码：\footnote{Mininet GitHub ：https://github.com/mininet/mininet}
执行以下命令安装依赖并启动：
\begin{lstlisting}[language=bash, caption={Mininet 安装与测试}]
# 克隆 Mininet 源码仓库
git clone https://github.com/mininet/mininet.git
# 进入 Mininet 目录
cd mininet

sudo util/install.sh -a
\end{lstlisting}


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{Figures/13.png}
    \caption{Mininet测试}
\end{figure}



\subsection{\textbf{算法实现}}

\quad\quad 为了实现上述建模，首先需要基于 Ryu 控制器框架设计并实现了一个多控制器保活检测机制，旨在提高网络控制平面在多控制器场景下的稳定性和可维护性。该控制器程序的主要功能包括：

\begin{itemize}
\item 每个控制器管理一个特定子集的交换机（由其 dpid 标识）；
\item 为每个控制器选定一个主交换机（Master Datapath）作为保活检测的对象；
\item 周期性地向该 Master 交换机发送 OpenFlow 的 EchoRequest 消息，用于检测其连接状态；
\item 若在设定的超时时间内未收到 EchoReply 响应，则判定该交换机失联，并将其从控制器的管理列表中移除；
\item 同时，实现了基本的 OpenFlow 事件响应处理逻辑，包括交换机连接（SwitchFeatures）、EchoReply 接收以及状态变更（连接断开）等。
\end{itemize}

\noindent 完整代码如下:
\begin{lstlisting}[language=bash, caption={多控制器保活检测机制代码}]
from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import MAIN_DISPATCHER, CONFIG_DISPATCHER, DEAD_DISPATCHER, set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib import hub

class MyMultiController(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    KEEPALIVE_INTERVAL = 5  # 秒
    TIMEOUT = 15            # 超时秒数

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.keepalive_lists = {}    # {controller_id: [dpid1, dpid2, ...]}
        self.timers = {}             # {dpid: seconds}
        self.datapaths = {}          # {dpid: datapath}
        # 启动保活线程
        self.keepalive_thread = hub.spawn(self._keepalive_loop)

    def _keepalive_loop(self):
        while True:
            try:
                hub.sleep(self.KEEPALIVE_INTERVAL)
                for ctrl_id, lst in list(self.keepalive_lists.items()):
                    if not lst:
                        continue
                    master_dpid = lst[0]
                    self.timers[master_dpid] += self.KEEPALIVE_INTERVAL
                    # 超时检测
                    if self.timers[master_dpid] > self.TIMEOUT:
                        self.logger.warning(f"Master {master_dpid} timed out for Controller {ctrl_id}, removing")
                        self.remove_datapath_from_lists(master_dpid)
                        self.datapaths.pop(master_dpid, None)
                        self.timers.pop(master_dpid, None)
                        continue
                    # 发送Echo请求
                    if master_dpid in self.datapaths:
                        datapath = self.datapaths[master_dpid]
                        parser = datapath.ofproto_parser
                        echo_req = parser.OFPEchoRequest(datapath, data=b'keepalive')
                        datapath.send_msg(echo_req)
                        self.logger.info(f"Sent Echo Request from Master {master_dpid} for Controller {ctrl_id}")
            except Exception as e:
                self.logger.error(f"Exception in keepalive loop: {e}")

    def get_controller_id(self, dpid):

        controller_map = {
            1: [1, 3, 4],          
             2: [2, 4],          
             3: [2, 3, 4],   }
        for ctrl_id, dpid_list in controller_map.items():
            if dpid in dpid_list:
                return ctrl_id
        return None

    def remove_datapath_from_lists(self, dpid):

        for ctrl_id, lst in self.keepalive_lists.items():
            if dpid in lst:
                lst.remove(dpid)
                self.logger.info(f"Removed {dpid} from keepalive list of Controller {ctrl_id}")
     
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        dpid = datapath.id
        self.logger.info(f"Switch connected: {dpid}")
        self.datapaths[dpid] = datapath
        controller_id = self.get_controller_id(dpid)
        if controller_id is None:
            self.logger.warning(f"Unknown controller for switch {dpid}")
            return

        if controller_id not in self.keepalive_lists:
            self.keepalive_lists[controller_id] = []
        if dpid not in self.keepalive_lists[controller_id]:
            self.keepalive_lists[controller_id].append(dpid)
            self.logger.info(f"Added {dpid} to keepalive list of Controller {controller_id}")
        self.timers[dpid] = 0

        if self.keepalive_lists[controller_id][0] == dpid:
            self.logger.info(f"Datapath {dpid} is Master for Controller {controller_id}")
            self.install_table_miss_flow(datapath)
           
        else:
            self.logger.info(f"Datapath {dpid} is in standby (Slave) for Controller {controller_id}")

    def install_table_miss_flow(self, datapath):

        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        match = parser.OFPMatch()  # 匹配所有包
        actions = [parser.OFPActionOutput(ofproto.OFPP_FLOOD)]  # flood到所有端口
        instructions = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]

        mod = parser.OFPFlowMod(
        datapath=datapath,
        priority=0,
        match=match,
        instructions=instructions
        )
        datapath.send_msg(mod)
        self.logger.info(f"Installed default table-miss flow on switch {datapath.id}")

    @set_ev_cls(ofp_event.EventOFPEchoReply, MAIN_DISPATCHER)
    def echo_reply_handler(self, ev):
        dpid = ev.msg.datapath.id
        self.logger.info(f"Received Echo Reply from {dpid}")
        self.timers[dpid] = 0  # 重置计时器

    @set_ev_cls(ofp_event.EventOFPStateChange, [MAIN_DISPATCHER, DEAD_DISPATCHER])
    def state_change_handler(self, ev):
        datapath = ev.datapath
        dpid = datapath.id

        if ev.state == DEAD_DISPATCHER:
            self.logger.info(f"Datapath {dpid} disconnected, removing from keepalive list")
            self.remove_datapath_from_lists(dpid)
            self.datapaths.pop(dpid, None)
            self.timers.pop(dpid, None)                 
\end{lstlisting}


为了模拟多控制器的实际应用环境，我们进一步构建了一个拓扑结构，并将交换机划分给多个逻辑控制器，形成如下的控制域建模：
\begin{itemize}
\item Controller 1 管理交换机 ${1, 3, 4}$，其中交换机 1 为 Master；
\item Controller 2 管理交换机 ${2, 4}$，其中交换机 2 为 Master；
\item Controller 3 管理交换机 ${2, 3, 4}$，其中交换机 2 为 Master；
\end{itemize}

 每个控制器通过维护独立的交换机列表与计时器机制，实现了对其主交换机的独立健康监测。若某个主交换机失联，对应控制器可根据优先顺序将管理权转交给同一组内的其他交换机，实现一定程度上的容错切换能力（Slave 转 Master 的潜力支持）。

 此外，在 Master 交换机首次接入时，会向其安装默认的 table-miss 流表项，实现基础的数据包洪泛（flooding）行为，从而保证网络的连通性与基本转发功能。

\noindent 完整代码如下:

\begin{lstlisting}[language=bash, caption={拓扑结构代码}]
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController
from mininet.cli import CLI
from mininet.link import TCLink

class MyTopo(Topo):
    def build(self):
        # 添加主机和交换机
        h1 = self.addHost('h1')
        h2 = self.addHost('h2')
        h3 = self.addHost('h3')
        h4 = self.addHost('h4')

        s1 = self.addSwitch('s1')
        s2 = self.addSwitch('s2')
        s3 = self.addSwitch('s3')
        s4 = self.addSwitch('s4')

        # 建立连接
        self.addLink(h1, s1)
        self.addLink(h2, s2)
        self.addLink(h3, s3)
        self.addLink(h4, s4)

        self.addLink(s1, s2)
        self.addLink(s2, s3)
        self.addLink(s3, s4)
        self.addLink(s4, s1)

if __name__ == '__main__':
    from mininet.log import setLogLevel
    setLogLevel('info')

    c1 = RemoteController('c1', ip='127.0.0.1', port=6651)
    c2 = RemoteController('c2', ip='127.0.0.1', port=6652)
    c3 = RemoteController('c3', ip='127.0.0.1', port=6653)

    net = Mininet(topo=MyTopo(), controller=None, link=TCLink)

    net.addController(c1)
    net.addController(c2)
    net.addController(c3)

    # 启动网络并指定每个交换机的控制器列表（注意顺序）
    net.start()

    # 控制器绑定优先级，Master 是第一个
    net.get('s1').start([c1])            # s1 只连接 c1
    net.get('s2').start([c2, c3])        # c2是Master，c3是Slave
    net.get('s3').start([c1, c3])        # 只有一个Controller
    net.get('s4').start([c1, c2, c3])    # 多个控制器

    CLI(net)
    net.stop()
\end{lstlisting}




\subsection{\textbf{仿真步骤}}
为了清晰展示实验过程，仿真步骤严格按照建模逻辑进行排列，确保逻辑一致性与可重复性。\\
\noindent \textbf{步骤1：Controller1 与实例1、3、4 建立连接}\\
\noindent 从控制器日志中可观察到：控制器1 成为实例 s1 的 Master，而对实例 s3 与 s4 为 Slave 状态。
\begin{center}
    \includegraphics[width=1\textwidth]{Figures/14.png}
    \captionsetup{type=figure}
    \captionof{figure}{Controller1 与实例1、3、4 建立连接}
\end{center}


\noindent \textbf{步骤2：Controller2 与实例2、4 建立连接}\\
\noindent 从控制器日志中可观察到：控制器2 成为实例 s2 与 s4 的 Master。
\begin{center}
    \includegraphics[width=1\textwidth]{Figures/15.png}
    \captionsetup{type=figure}
    \captionof{figure}{Controller2 与实例2、4 建立连接}
\end{center}



\noindent \textbf{步骤3：Controller3 与实例2、3、4 建立连接}\\
\noindent 从控制器日志中可观察到：控制器3 成为实例 s2 与 s3 的 Master，而在实例 s4 上为 Slave。
\begin{center}
    \includegraphics[width=1\textwidth]{Figures/16.png}
    \captionsetup{type=figure}
    \captionof{figure}{Controller3 与实例2、3、4 建立连接}
\end{center}


\noindent \textbf{步骤4:查看控制器与交换机连通性}

\begin{center}
    \includegraphics[width=1\textwidth]{Figures/23.png}
    \captionsetup{type=figure}
    \captionof{figure}{控制器与交换机连通性}
\end{center}



\noindent \textbf{步骤5：物理连接中断 —— 实例2 被删除}\\

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{Figures/17.png}
\caption{实例2 被删除}
\end{figure}

\noindent 查看 Controller2 与 Controller3 的日志：
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{Figures/18.png}
\caption{Controller2 日志}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{Figures/19.png}
\caption{Controller3 日志}
\end{figure}

\noindent 可以验证实例 s2 已从两个控制器断开，系统响应正常：\\

\vspace{1em}

\noindent \textbf{步骤6：物理连接恢复 —— 实例2 被恢复}
\begin{center}
    \includegraphics[width=1\textwidth]{Figures/20.png}
    \captionsetup{type=figure}
    \captionof{figure}{实例2 被恢复}
\end{center}

\noindent 恢复连接后，观察 Controller2 与 Controller3 的日志：
\begin{center}
    \includegraphics[width=1\textwidth]{Figures/21.png}
    \captionsetup{type=figure}
    \captionof{figure}{Controller2 日志}
\end{center}

\begin{center}
    \includegraphics[width=1\textwidth]{Figures/22.png}
    \captionsetup{type=figure}
    \captionof{figure}{Controller3 日志}
\end{center}

 可以发现：s2 再次同时与两个控制器建立连接，并且两个控制器均认为自己是 Master。这暴露出一个问题：\textbf{Ryu 默认每个控制器都认为自身是 Master，除非显式地使用 set\_role 命令进行角色指定。}


\subsection{\textbf{实验总结}}

\quad\quad 本实验针对多实例连接同一控制器场景下的保活机制优化问题，进行了建模与仿真，并设计了一种基于实例间协商选主的优化算法。通过构建包含多个 OpenFlow 实例与多个 Ryu 控制器的 Mininet 仿真环境，逐步模拟了实例与控制器之间的连接建立、物理中断以及连接恢复等过程，全面观察并记录了控制器端的连接日志与角色状态变化。

实验结果表明，在传统 OpenFlow 模型中，所有实例均会独立向控制器发送 Echo Request 报文，控制器需逐一回应，从而造成显著的资源浪费。而本实验中提出的优化机制，通过在交换机侧协商选出唯一的 Master 实例，仅由其负责与控制器进行保活交互，显著减少了冗余报文的数量，降低了控制器和交换机的处理负担。

此外，实验还验证了在连接中断和恢复场景下，系统能够实现 Master 实例的自动重新选举，维持连接关系的连续性与稳定性，证明了所提算法的健壮性与可行性。由于时间限制，实验尚未进行定量评估，例如对报文数量、处理时延等性能指标的统计与分析，后续工作将进一步补充相关数据以支撑优化效果的全面性与说服力。


\printbibliography

\end{document}
